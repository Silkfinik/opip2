<!DOCTYPE html>
<html lang="ru" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>ОПИП ИНТЕРАКТИВ 2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      src="https://unpkg.com/react@18/umd/react.development.js"
      crossorigin
    ></script>
    <script
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
      crossorigin
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&family=Inter:wght@400;500;600;700;900&display=swap&subset=cyrillic"
      rel="stylesheet"
    />
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        font-family: "Inter", sans-serif;
        -webkit-tap-highlight-color: transparent;
        background-color: #0f172a; /* slate-900 */
        position: relative;
      }
      body::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: repeating-linear-gradient(
          to bottom,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.05) 1px,
          transparent 1px,
          transparent 2px
        );
        opacity: 0.6;
        z-index: 1000;
      }
      .font-mono {
        font-family: "Roboto Mono", monospace;
      }
      .reveal-animation {
        animation: fadeIn 0.5s ease-in-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }
      @keyframes popIn {
        0% {
          opacity: 0;
          transform: scale(0.9);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      .animate-pop-in {
        opacity: 0;
        animation: popIn 0.5s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
      }
      @keyframes flicker {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }
      .animate-flicker {
        animation: flicker 0.2s ease-in-out 3;
      }
      @keyframes blink-caret {
        from,
        to {
          border-color: transparent;
        }
        50% {
          border-color: currentColor;
        }
      }
      .typing-caret {
        border-right: 0.15em solid currentColor;
        padding-right: 0.1em;
        animation: blink-caret 1s step-end infinite;
      }
      .typing-caret-done {
        border-right: none;
        padding-right: 0;
      }
      .text-glow {
        text-shadow: 0 0 8px currentColor;
      }
      .text-glow-red {
        text-shadow: 0 0 12px rgba(239, 68, 68, 0.8);
      }
      ::-webkit-scrollbar {
        width: 4px;
        height: 4px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 2px;
      }
      .scrollbar-hide::-webkit-scrollbar {
        display: none;
      }
      .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      .pb-safe {
        padding-bottom: env(safe-area-inset-bottom);
      }
      .progress-bar {
        transition: width 1s linear;
      }
    </style>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              primary: "#0f172a",
              secondary: "#475569",
              accent: "#2563eb",
            },
            animation: {
              "pulse-slow": "pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite",
            },
          },
        },
      };
    </script>
  </head>
  <body class="h-full text-slate-200 overflow-hidden">
    <div id="root" class="h-full"></div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
      import {
        getFirestore,
        doc,
        setDoc,
        onSnapshot,
        updateDoc,
        getDoc,
        collection,
        query,
        orderBy,
        deleteDoc,
        arrayUnion,
        arrayRemove,
        writeBatch,
      } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
      import {
        getAuth,
        signInAnonymously,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

      const firebaseConfig = {
        apiKey: "AIzaSyBokSMgEAnQE_EtgdilYf1DmMC8r0AzAO8",
        authDomain: "opip2-a90df.firebaseapp.com",
        projectId: "opip2-a90df",
        storageBucket: "opip2-a90df.firebasestorage.app",
        messagingSenderId: "856863305799",
        appId: "1:856863305799:web:020e2a266d6ed4e8498162",
      };

      const app = initializeApp(firebaseConfig);
      window.db = getFirestore(app);
      window.auth = getAuth(app);
      window.firebaseModules = {
        doc,
        setDoc,
        onSnapshot,
        updateDoc,
        getDoc,
        signInAnonymously,
        onAuthStateChanged,
        collection,
        query,
        orderBy,
        deleteDoc,
        arrayUnion,
        arrayRemove,
        writeBatch,
      };
    </script>

    <script type="text/babel" data-type="module">
      const { useState, useEffect, useRef, useMemo } = React;
      const {
        doc,
        setDoc,
        onSnapshot,
        updateDoc,
        getDoc,
        signInAnonymously,
        onAuthStateChanged,
        collection,
        query,
        orderBy,
        deleteDoc,
        arrayUnion,
        arrayRemove,
        writeBatch,
      } = window.firebaseModules;

      // [!!!] ВСТАВЬТЕ СЮДА ВАШ URL NETLIFY
      const EVALUATE_ATTACK_URL =
        "https://opip2-proxy.netlify.app/.netlify/functions/evaluate";
      // [!!!]

      const ADMIN_CODE = "ADMIN";

      // [!!!] ИЗМЕНЕНИЕ: Все статические словари (DEFENSE, VULNERABILITY, ALL_KEYWORDS) удалены.

      const MANIPULATION_TYPES = {
        GUILT: { label: "ВЫЗВАТЬ ИЗВИНЕНИЯ" },
        FEAR: { label: "ПОТОРОПИТЬ / ДАВИТЬ" },
        AUTHORITY: { label: "ВЫЗВАТЬ СОГЛАСИЕ" },
        FLATTERY: { label: "ПОЛУЧИТЬ БЛАГОДАРНОСТЬ" },
      };

      function useTypewriter(text, speed = 50) {
        const [visibleIndex, setVisibleIndex] = useState(0);
        const [isDone, setIsDone] = useState(false);

        const textArray = React.useMemo(
          () => (text ? text.split("") : []),
          [text]
        );

        React.useEffect(() => {
          if (!text) {
            setVisibleIndex(0);
            setIsDone(true);
            return;
          }

          setVisibleIndex(0);
          setIsDone(false);
          let i = 0;

          if (speed === 0) {
            setVisibleIndex(text.length);
            setIsDone(true);
            return;
          }

          const timer = setInterval(() => {
            if (i < text.length) {
              i++;
              setVisibleIndex(i);
            } else {
              clearInterval(timer);
              setIsDone(true);
            }
          }, speed);

          return () => clearInterval(timer);
        }, [text, speed]);

        const displayedJsx = React.useMemo(() => {
          return (
            <>
              {textArray.map((char, index) => (
                <span
                  key={index}
                  style={{
                    visibility: index < visibleIndex ? "visible" : "hidden",
                  }}
                >
                  {char === " " ? "\u00A0" : char}
                </span>
              ))}
            </>
          );
        }, [textArray, visibleIndex]);

        return [displayedJsx, isDone];
      }

      function App() {
        const [gameState, setGameState] = useState("auth");
        const [userId, setUserId] = useState(null);
        const [gameId, setGameId] = useState("");
        const [myTeam, setMyTeam] = useState(null);
        const [gameData, setGameData] = useState(null);
        const [error, setError] = useState("");
        const [showOnboarding, setShowOnboarding] = useState(false);
        // [!!!] ИЗМЕНЕНИЕ: 'showInitialDictionary' удален.

        useEffect(() => {
          let uid = localStorage.getItem("negotiator_userId");
          if (!uid) {
            uid = "user_" + Math.random().toString(36).substring(2, 10);
            localStorage.setItem("negotiator_userId", uid);
          }
          setUserId(uid);

          signInAnonymously(window.auth)
            .then(async () => {
              const storedGameId = localStorage.getItem("negotiator_gameId");
              const storedMyTeam = localStorage.getItem("negotiator_myTeam");

              if (storedGameId && storedMyTeam) {
                const gameRef = doc(window.db, "games", storedGameId);
                const gameSnap = await getDoc(gameRef);

                if (gameSnap.exists()) {
                  const gameData = gameSnap.data();
                  if (gameData.players?.[storedMyTeam]?.includes(uid)) {
                    setGameId(storedGameId);
                    setMyTeam(storedMyTeam);
                    setGameState("game");
                    return;
                  } else {
                    localStorage.removeItem("negotiator_gameId");
                    localStorage.removeItem("negotiator_myTeam");
                  }
                } else {
                  localStorage.removeItem("negotiator_gameId");
                  localStorage.removeItem("negotiator_myTeam");
                }
              }
              setGameState("lobby");
            })
            .catch((e) => setError("Ошибка подключения: " + e.message));
        }, []);

        useEffect(() => {
          if (!gameId || !userId || gameState === "admin") return;
          const gameRef = doc(window.db, "games", gameId);
          const unsubscribe = onSnapshot(
            gameRef,
            (docSnap) => {
              if (docSnap.exists()) {
                const data = docSnap.data();
                setGameData(data);
                if (data.status === "revealed" && gameState !== "revealed")
                  setGameState("revealed");

                if (
                  myTeam &&
                  data.players?.[myTeam]?.includes(userId) &&
                  !data.speakers?.[myTeam]
                ) {
                  updateDoc(gameRef, {
                    [`speakers.${myTeam}`]: userId,
                  }).catch(console.error);
                }
              } else {
                if (["game", "revealed", "team_select"].includes(gameState)) {
                  setError("Сессия завершена.");
                  localStorage.removeItem("negotiator_gameId");
                  localStorage.removeItem("negotiator_myTeam");
                  setGameState("lobby");
                  setGameData(null);
                  setGameId("");
                }
              }
            },
            (err) => {
              console.error("Sync error:", err);
              setError("Ошибка синхронизации.");
            }
          );

          return () => {
            unsubscribe();
            if (myTeam && gameId && userId && gameState === "game") {
              const gameRef = doc(window.db, "games", gameId);

              getDoc(gameRef)
                .then((snap) => {
                  if (!snap.exists()) return;

                  const data = snap.data();
                  const batch = writeBatch(window.db);

                  batch.update(gameRef, {
                    [`players.${myTeam}`]: arrayRemove(userId),
                  });

                  if (data.speakers?.[myTeam] === userId) {
                    batch.update(gameRef, {
                      [`speakers.${myTeam}`]: null,
                    });
                  }

                  if (data.scouts?.[myTeam] === userId) {
                    batch.update(gameRef, {
                      [`scouts.${myTeam}`]: null,
                    });
                  }

                  return batch.commit();
                })
                .catch(console.error);
            }
          };
        }, [gameId, userId, gameState, myTeam]);

        const enterGame = async (team) => {
          setMyTeam(team);
          localStorage.setItem("negotiator_myTeam", team);
          await updateDoc(doc(window.db, "games", gameId), {
            [`players.${team}`]: arrayUnion(userId),
          });
          setShowOnboarding(true);
          setGameState("game");
        };

        if (gameState === "auth")
          return <LoadingScreen message="INITIALIZING..." />;
        if (gameState === "lobby")
          return (
            <Lobby
              onJoin={async (id) => {
                if (id === ADMIN_CODE) {
                  setGameState("admin");
                  return;
                }
                const snap = await getDoc(doc(window.db, "games", id));
                if (snap.exists()) {
                  localStorage.setItem("negotiator_gameId", id);
                  setGameId(id);
                  setGameState("team_select");
                } else {
                  setError("СЕССИЯ НЕ НАЙДЕНА");
                }
              }}
              error={error}
              setError={setError}
            />
          );
        if (gameState === "admin")
          return <AdminPanel onExit={() => setGameState("lobby")} />;
        if (gameState === "team_select")
          return (
            <TeamSelect
              onSelect={enterGame}
              onBack={() => {
                localStorage.removeItem("negotiator_gameId");
                setGameId("");
                setGameState("lobby");
              }}
            />
          );
        if (gameState === "game" && gameData) {
          // [!!!] ИЗМЕНЕНИЕ: Логика 'showInitialDictionary' удалена.
          if (showOnboarding)
            return (
              <Onboarding
                onStart={() => {
                  setShowOnboarding(false);
                }}
                team={myTeam}
              />
            );

          return (
            <GameRoom
              gameId={gameId}
              myTeam={myTeam}
              userId={userId}
              gameData={gameData}
            />
          );
        }
        if (gameState === "revealed" && gameData)
          return (
            <RevealScreen
              gameData={gameData}
              myTeam={myTeam}
              onExit={() => {
                localStorage.removeItem("negotiator_gameId");
                localStorage.removeItem("negotiator_myTeam");
                setGameId("");
                setGameState("lobby");
              }}
            />
          );
        return <LoadingScreen message="LOADING..." />;
      }

      function LoadingScreen({ message }) {
        return (
          <div className="flex items-center justify-center h-full bg-slate-900 text-slate-400 font-mono">
            <div className="flex flex-col items-center animate-pulse">
              <div className="text-xs tracking-widest">{message}</div>
            </div>
          </div>
        );
      }

      function Lobby({ onJoin, error, setError }) {
        const [joinId, setJoinId] = useState("");
        const [key, setKey] = useState(0);

        useEffect(() => {
          if (error) setKey((k) => k + 1);
        }, [error]);

        return (
          <div className="flex flex-col items-center justify-center h-full p-6 bg-slate-900 text-slate-300 reveal-animation">
            <div className="w-full max-w-md text-center">
              <div className="text-lg text-slate-400 mb-8 font-mono mt-8">
                ТЕРМИНАЛ БЕЗОПАСНОГО ДОСТУПА
              </div>

              <div
                className="flex items-center justify-center gap-3 mb-4 animate-pop-in font-mono"
                style={{ animationDelay: "0.5s" }}
              >
                <div className="w-2 h-2 bg-green-500 animate-pulse"></div>
                <div className="text-xs text-green-700">
                  [✓] STATUS: SECURE_CONNECTION [ESTABLISHED]
                </div>
              </div>

              {error && (
                <div
                  key={key}
                  className="text-red-500 p-3 text-xs font-mono mb-4 border border-red-500/50 bg-red-900/20 animate-flicker rounded-lg"
                >
                  [X] AUTH_ERROR: {error}
                </div>
              )}

              <div
                className="space-y-3 text-left animate-pop-in font-mono"
                style={{ animationDelay: "0.7s" }}
              >
                <label
                  htmlFor="sessionId"
                  className="text-xs font-bold text-slate-300 block"
                >
                  > ВВЕДИТЕ КЛЮЧ ДОСТУПА К СЕССИИ:
                </label>
                <input
                  id="sessionId"
                  type="text"
                  value={joinId}
                  onChange={(e) => setJoinId(e.target.value.toUpperCase())}
                  placeholder="XXXXX"
                  className="w-full p-4 bg-slate-800 border-none rounded-lg text-white font-mono text-xl uppercase tracking-widest focus:border-blue-500 outline-none transition text-center placeholder:text-slate-500"
                  maxLength={10}
                  onFocus={() => setError("")}
                />
                <button
                  onClick={() => onJoin(joinId)}
                  disabled={!joinId}
                  className="w-full py-4 bg-blue-600 text-white font-bold tracking-widest hover:bg-blue-500 transition disabled:opacity-50 rounded-lg"
                >
                  [ ПОДКЛЮЧИТЬСЯ → ]
                </button>
              </div>
            </div>
          </div>
        );
      }

      // [!!!] ИЗМЕНЕНИЕ: Компонент `DictionaryScreen` полностью удален.

      // [НОВЫЙ КОМПОНЕНТ]
      function InterceptorScreen({ onClose, opponentAttacks }) {
        const [timeLeft, setTimeLeft] = useState(5);

        useEffect(() => {
          if (timeLeft <= 0) {
            onClose();
            return;
          }
          const timer = setInterval(() => {
            setTimeLeft((t) => t - 1);
          }, 1000);
          return () => clearInterval(timer);
        }, [timeLeft, onClose]);

        return (
          <div className="fixed inset-0 bg-slate-900/80 backdrop-blur-sm text-white z-50 flex flex-col p-4 sm:p-6 reveal-animation">
            <div className="flex justify-between items-center mb-2 font-mono">
              <h2 className="text-lg font-bold tracking-widest text-red-500 animate-flicker text-glow-red">
                ПЕРЕХВАТ ДАННЫХ [ TOP SECRET ]
              </h2>
              <div className="text-xl font-bold">{timeLeft}s</div>
            </div>

            <p className="text-yellow-400 font-mono text-xs mb-4 border border-yellow-500/50 bg-yellow-900/20 p-3 rounded-lg">
              [!] ВНИМАНИЕ: Это оставшиеся заряды атак противника. Запомните и
              передайте Спикеру.
            </p>

            <div className="flex-1 overflow-y-auto">
              <div className="grid grid-cols-1 gap-2">
                {Object.entries(MANIPULATION_TYPES).map(([key, data]) => {
                  const count = opponentAttacks?.[key] ?? 0;
                  return (
                    <div
                      key={key}
                      className="flex justify-between items-center bg-slate-700 text-slate-300 px-4 py-3 text-sm font-mono border border-slate-600 rounded"
                    >
                      <span className="opacity-50 mr-2">{data.label}</span>
                      <span className="text-lg font-bold text-white bg-slate-800 px-3 py-1 rounded">
                        {count}
                      </span>
                    </div>
                  );
                })}
              </div>
            </div>
            <div className="h-1 bg-slate-800 mt-6">
              <div
                className="h-full bg-red-500 progress-bar"
                style={{ width: `${(timeLeft / 5) * 100}%` }}
              ></div>
            </div>
            <button
              onClick={onClose}
              className="w-full py-4 bg-white text-slate-900 font-bold font-mono tracking-widest hover:bg-slate-200 transition mt-6 rounded-lg"
            >
              ЗАКРЫТЬ [ -> ]
            </button>
          </div>
        );
      }

      function TeamSelect({ onSelect, onBack }) {
        const [typedTitle, isTitleDone] = useTypewriter("ВЫБОР СТОРОНЫ", 60);

        return (
          <div className="flex flex-col h-full p-6 bg-slate-900 reveal-animation">
            <button
              onClick={onBack}
              className="self-start text-xs font-mono text-slate-400 mb-8 hover:text-slate-200 transition"
            >
              [ НАЗАД ]
            </button>
            <div className="text-center">
              <h2
                className={`text-2xl font-bold mb-2 tracking-tight text-white text-glow inline-block ${
                  isTitleDone ? "typing-caret-done" : "typing-caret"
                }`}
              >
                {typedTitle}
              </h2>
            </div>
            <p className="text-center text-sm text-slate-400 mb-8 font-mono">
              Сторона определяет ваши стартовые цели в переговорах.
            </p>
            <div className="grid gap-4 max-w-md mx-auto w-full">
              <TeamCard
                label="⏵ ALPHA CORP."
                desc="Покупатель / Атакующая сторона"
                color="bg-blue-600"
                hoverBorder="hover:border-blue-500"
                onClick={() => onSelect("alpha")}
                delay={100}
              />
              <TeamCard
                label="⏵ BETA INC."
                desc="Продавец / Удерживающая сторона"
                color="bg-emerald-600"
                hoverBorder="hover:border-emerald-500"
                onClick={() => onSelect("beta")}
                delay={200}
              />
            </div>
          </div>
        );
      }

      function TeamCard({
        label,
        desc,
        color,
        hoverBorder,
        onClick,
        delay = 0,
      }) {
        return (
          <button
            onClick={onClick}
            className={`group p-6 text-left transition-all active:scale-[0.98] bg-slate-800 border-2 border-slate-700 ${hoverBorder} hover:bg-slate-700/50 animate-pop-in rounded-lg`}
            style={{ animationDelay: `${delay}ms` }}
          >
            <div
              className={`text-sm font-bold mb-1 ${color.replace(
                "bg-",
                "text-"
              )}`}
            >
              {label}
            </div>
            <div className="text-xs font-mono text-slate-400">{desc}</div>
          </button>
        );
      }

      function Onboarding({ onStart, team }) {
        const [view, setView] = useState("briefing");
        const isAlpha = team === "alpha";
        const [typedTitle, isTitleDone] = useTypewriter("ФАЙЛ #T-729", 60);

        const theme = isAlpha
          ? {
              accent: "text-blue-400",
              accentHover: "hover:text-blue-300",
              bg: "bg-blue-600",
              border: "border-blue-500",
              hoverBorder: "hover:border-blue-500",
              glow: "text-blue-400 text-glow",
            }
          : {
              accent: "text-emerald-400",
              accentHover: "hover:text-emerald-300",
              bg: "bg-emerald-600",
              border: "border-emerald-500",
              hoverBorder: "hover:border-emerald-500",
              glow: "text-emerald-400 text-glow",
            };

        const TABS = [
          { id: "briefing", label: "ПЕРЕГОВОРЫ" },
          { id: "goals", label: "ЦЕЛИ" },
          { id: "tools", label: "ИНСТРУМЕНТЫ" },
        ];

        // [ЛЕГЕНДА]: Этот контент поддерживает иллюзию серьезных переговоров.
        const BriefingContent = () => (
          <>
            <h3 className="text-lg font-bold text-white mb-4">
              Обзор ситуации
            </h3>
            <div className="space-y-4 text-sm text-slate-300">
              <p>
                Корпорация "Alpha" инициировала враждебное поглощение "Beta
                Inc.". Переговоры зашли в тупик.
              </p>
              <p>
                Вам предстоит принять участие в финальном раунде в качестве
                ключевого переговорщика от вашей стороны.
              </p>
              <p className="font-bold text-yellow-400/80">
                Система будет анализировать каждое ваше слово и тактический ход
                для оценки вашей эффективности.
              </p>
              <p className="font-bold text-slate-100">
                {isAlpha
                  ? 'Ваша задача — "дожать" Beta Inc. и закрыть сделку на ваших условиях.'
                  : "Ваша задача — отстоять позицию Beta Inc. и не допустить невыгодной сделки."}
              </p>
            </div>
          </>
        );

        // [ЛЕГЕНДА]: Эти цели также являются частью "серьезной" симуляции.
        const GoalsContent = () => {
          const goals = isAlpha
            ? [
                "ЦЕНА: Добиться снижения финальной стоимости с $500М до $420М (-15%).",
                "КОНТРОЛЬ: Получить полный операционный контроль над R&D отделом Beta Inc.",
                "СРОКИ: Закрыть сделку в рамках этой сессии.",
              ]
            : [
                "ЦЕНА: Отстоять оценку в $500М. Не поддаваться на давление.",
                "КОНТРОЛЬ: Гарантировать 2 места для основателей Beta в новом совете директоров.",
                "АВТОНОМИЯ: Сохранить R&D отдел как независимую структуру.",
              ];
          return (
            <>
              <h3 className="text-lg font-bold text-white mb-4">
                Задачи: {team.toUpperCase()}
              </h3>
              <ul className="space-y-3">
                {goals.map((goal, i) => (
                  <li
                    key={i}
                    className="flex gap-4 p-4 bg-slate-800 border border-slate-700 rounded-lg"
                  >
                    <span className={`font-mono ${theme.accent}`}>
                      0{i + 1}.
                    </span>
                    <span className="text-sm text-slate-200">{goal}</span>
                  </li>
                ))}
              </ul>
            </>
          );
        };

        // [!!!] ИЗМЕНЕНИЕ: Этот контент ПОЛНОСТЬЮ ПЕРЕПИСАН
        const ToolsContent = () => (
          <>
            <h3 className="text-lg font-bold text-white mb-4">Правила Игры</h3>

            <div className="mb-6">
              <h4 className="font-bold text-slate-100 mb-2">
                1. Как Атаковать
              </h4>
              <div className="text-sm space-y-3 text-slate-300 bg-slate-800 p-4 border border-slate-700 rounded-lg">
                <p>
                  Четыре кнопки под полем ввода — это ваши Атаки. У каждой
                  ограниченный запас.
                </p>
                <p className="font-bold">Как это работает:</p>
                <ol className="list-decimal list-inside space-y-2 pl-2">
                  <li>Пишете текст.</li>
                  <li>Выбираете Атаку (кнопку).</li>
                  <li>Отправляете.</li>
                  <li>
                    В конце раунда ИИ-Судья решит, <strong>поддался</strong> ли
                    оппонент. Если да — вы получаете очко.
                  </li>
                </ol>
              </div>
            </div>

            <div className="mb-6">
              <h4 className="font-bold text-slate-100 mb-2">
                2. Как Защищаться
              </h4>
              <div className="text-sm space-y-3 text-slate-300 bg-slate-800 p-4 border border-slate-700 rounded-lg">
                <p>
                  В этой игре нет кнопки "Защита". Ваша защита — это то, что вы
                  пишете.
                </p>
                <p>
                  Когда вас атакуют, ИИ-Судья оценит все ваши ответы за раунд и
                  вынесет вердикт
                </p>
              </div>
            </div>

            <div>
              <h4 className="font-bold text-slate-100 mb-2">
                3. Роли и Правила Связи
              </h4>
              <ul className="space-y-3 text-sm text-slate-300">
                <li className="flex gap-3 p-3 bg-slate-800 border border-slate-700 rounded-lg">
                  <span className={`font-mono ${theme.accent}`}>01.</span>
                  <span>
                    <strong>РЕЖИМ РАЦИИ:</strong> Говорит только одна команда.
                    Закончил? Жми [ПЕРЕДАТЬ КАНАЛ].
                  </span>
                </li>
                <li className="flex gap-3 p-3 bg-slate-800 border border-slate-700 rounded-lg">
                  <span className={`font-mono ${theme.accent}`}>02.</span>
                  <span>
                    <strong>СПИКЕР:</strong> Писать и атаковать может{" "}
                    <strong>только 1 игрок</strong> — Спикер. Остальные —
                    Наблюдатели.
                  </span>
                </li>
                <li className="flex gap-3 p-3 bg-slate-800 border border-slate-700 rounded-lg">
                  <span className={`font-mono ${theme.accent}`}>03.</span>
                  <span>
                    <strong>ПЕРЕХВАТЧИК (Новая роль):</strong> Иногда
                    Наблюдатель становится 'Перехватчиком'. На 5 секунд он{" "}
                    <strong>увидит запас атак врага</strong>. Его задача —
                    быстро передать это спикеру.
                  </span>
                </li>
              </ul>
            </div>
          </>
        );

        return (
          <div className="fixed inset-0 bg-slate-900 text-slate-200 z-50 flex flex-col w-full h-full reveal-animation">
            <div className="w-full h-full bg-slate-900 flex flex-col">
              <div
                className={`p-4 bg-slate-800 border-b ${theme.border} flex-shrink-0`}
              >
                <div className="flex justify-between items-center mb-1">
                  <h2
                    className={`text-xl font-bold text-white tracking-tighter ${
                      theme.glow
                    } inline-block ${
                      isTitleDone ? "typing-caret-done" : "typing-caret"
                    }`}
                  >
                    {typedTitle}
                  </h2>
                  <span
                    className={`px-3 py-1 ${theme.bg} text-white text-xs font-mono font-bold tracking-widest rounded-full`}
                  >
                    {team.toUpperCase()}
                  </span>
                </div>
                <div className={`text-xs ${theme.accent} font-mono`}>
                  СТАТУС: АКТИВНЫЙ
                </div>
              </div>

              <div className="flex flex-col sm:flex-row border-b border-slate-700 flex-shrink-0">
                {TABS.map((tab) => (
                  <button
                    key={tab.id}
                    onClick={() => setView(tab.id)}
                    className={`flex-1 p-4 text-xs font-bold font-mono tracking-widest transition ${
                      view === tab.id
                        ? `${theme.bg} text-white`
                        : "text-slate-400 hover:bg-slate-700/50 hover:text-slate-200"
                    }`}
                  >
                    {tab.label}
                  </button>
                ))}
              </div>

              <div className="p-4 overflow-y-auto scrollbar-hide">
                {view === "briefing" && <BriefingContent />}
                {view === "goals" && <GoalsContent />}
                {view === "tools" && <ToolsContent />}
              </div>

              <div className="p-4 border-t border-slate-700 bg-slate-800 mt-auto flex-shrink-0">
                <button
                  onClick={onStart}
                  className="w-full py-4 bg-white text-slate-900 font-bold font-mono tracking-widest hover:bg-slate-200 transition rounded-lg"
                >
                  [ НАЧАТЬ ПЕРЕГОВОРЫ ⏵ ]
                </button>
              </div>
            </div>
          </div>
        );
      }

      function ChatMessage({ text, team, isMe, isOpponent, themeColors }) {
        const [typedText, isDone] = useTypewriter(text, isOpponent ? 20 : 0);

        return (
          <div
            className={`flex flex-col ${isMe ? "items-end" : "items-start"}`}
          >
            <div className="text-[10px] font-mono text-slate-400 mb-1 mx-2 uppercase">
              {team}
            </div>
            <div
              className={`max-w-[80%] p-3 text-sm break-words rounded-2xl whitespace-pre-wrap ${
                isMe
                  ? `${themeColors.buttonBg} text-white rounded-br-lg`
                  : "bg-slate-700 text-slate-200 rounded-bl-lg"
              }`}
            >
              <span
                className={
                  isOpponent && !isDone ? "typing-caret" : "typing-caret-done"
                }
              >
                {typedText}
              </span>
            </div>
          </div>
        );
      }

      function GameRoom({ gameId, myTeam, userId, gameData }) {
        const [message, setMessage] = useState("");
        const [selectedManipulation, setSelectedManipulation] = useState(null);
        const [isMyScoutTurn, setIsMyScoutTurn] = useState(false);
        const [isSending, setIsSending] = useState(false);
        const chatRef = useRef();

        const myAttackCounts = gameData.attacks?.[myTeam];

        const isMyTurn = gameData.turn === myTeam;
        const isMySpeaker = gameData.speakers?.[myTeam] === userId;
        const myScoutId = gameData.scouts?.[myTeam];
        const canAct = isMyTurn && isMySpeaker;

        const [hasAttackedThisTurn, setHasAttackedThisTurn] = useState(false);

        const themeColors = useMemo(() => {
          return myTeam === "alpha"
            ? {
                border: "border-blue-500",
                focusBorder: "focus:border-blue-500",
                highlightBorder: "border-blue-500",
                buttonBg: "bg-blue-600",
                buttonHoverBg: "hover:bg-blue-500",
                buttonText: "text-white",
                buttonBorder: "border-blue-600",
                glow: "text-blue-400 text-glow",
                shieldBg: "bg-blue-500",
              }
            : {
                border: "border-emerald-500",
                focusBorder: "focus:border-emerald-500",
                highlightBorder: "border-emerald-500",
                buttonBg: "bg-emerald-600",
                buttonHoverBg: "hover:bg-emerald-500",
                buttonText: "text-white",
                buttonBorder: "border-emerald-600",
                glow: "text-emerald-400 text-glow",
                shieldBg: "bg-emerald-500",
              };
        }, [myTeam]);

        useEffect(
          () => chatRef.current?.scrollTo(0, chatRef.current.scrollHeight),
          [gameData.messages]
        );

        useEffect(() => {
          if (isMyTurn) {
            setHasAttackedThisTurn(false);
          }
        }, [isMyTurn]);

        useEffect(() => {
          if (isMyTurn && userId === myScoutId && !isMySpeaker) {
            setIsMyScoutTurn(true);
          }
        }, [isMyTurn, userId, myScoutId, isMySpeaker]);

        // [!!!] ИЗМЕНЕНИЕ: `handleSend` (упрощенный)
        const handleSend = async (e) => {
          e.preventDefault();
          if (!message.trim() || !canAct || isSending) return;

          setIsSending(true);
          const text = message.trim();
          setMessage("");

          const updates = {
            messages: arrayUnion({
              text,
              team: myTeam,
              senderId: userId,
              timestamp: Date.now(),
              manipulationAttempt: selectedManipulation,
              turnCount: gameData.turnCount || 0,
            }),
          };

          try {
            await updateDoc(doc(window.db, "games", gameId), updates);
          } catch (err) {
            console.error("Update failed:", err);
          } finally {
            setIsSending(false);
            if (selectedManipulation) {
              setHasAttackedThisTurn(true);
              setSelectedManipulation(null);
            }
          }
        };

        // [!!!] ИЗМЕНЕНИЕ: `handleEndTurn` (3-уровневая логика)
        const handleEndTurn = async () => {
          if (isSending) return;
          setIsSending(true);

          try {
            const updates = {};
            const opponentTeam = myTeam === "alpha" ? "beta" : "alpha";

            // [ФАЗА 1: РАЗРЕШЕНИЕ ВХОДЯЩЕЙ АТАКИ]
            if (
              gameData.pendingAttack &&
              gameData.pendingAttack.team !== myTeam
            ) {
              const attackerTeam = gameData.pendingAttack.team;
              const attackerCurrentScore = gameData.scores?.[attackerTeam] || 0;
              const myCurrentScore = gameData.scores?.[myTeam] || 0;

              const messagesToAnalyze =
                gameData.messages
                  .filter(
                    (m) =>
                      m.team === myTeam && m.turnCount === gameData.turnCount
                  )
                  .map((m) => m.text)
                  .join("\n") || "";

              let isSuccess = false;
              let isDefenseSuccess = false;
              let aiResponse = "NEUTRAL";

              if (messagesToAnalyze.length > 0) {
                try {
                  const response = await fetch(EVALUATE_ATTACK_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                      attackType: gameData.pendingAttack.type,
                      responseText: messagesToAnalyze,
                    }),
                  });

                  if (response.ok) {
                    const result = await response.json();
                    aiResponse = result.result || "NEUTRAL";

                    if (aiResponse === "VULNERABLE") {
                      isSuccess = true;
                    } else if (aiResponse === "STRONG_DEFENSE") {
                      isDefenseSuccess = true;
                    }
                  } else {
                    aiResponse = `API Error: ${response.statusText}`;
                  }
                } catch (apiError) {
                  console.error("Gemini API call failed:", apiError);
                  aiResponse = apiError.message;
                }
              }

              if (isSuccess) {
                updates[`scores.${attackerTeam}`] = attackerCurrentScore + 1;
              } else if (isDefenseSuccess) {
                updates[`scores.${myTeam}`] = myCurrentScore + 1;
              }

              updates.manipulationLog = arrayUnion({
                attacker: gameData.pendingAttack.team,
                victim: myTeam,
                type: gameData.pendingAttack.type,
                success: isSuccess,
                defenseSuccess: isDefenseSuccess,
                response: messagesToAnalyze.substring(0, 80),
                aiResponse: aiResponse,
              });

              updates.pendingAttack = null;
            }

            // [ФАЗА 2: ЗАПУСК НАШЕЙ АТАКИ]
            const myAttackMessage = gameData.messages
              .filter(
                (m) =>
                  m.team === myTeam &&
                  m.turnCount === gameData.turnCount &&
                  m.manipulationAttempt
              )
              .pop();

            if (myAttackMessage) {
              const attackType = myAttackMessage.manipulationAttempt;
              const currentAttackCount =
                gameData.attacks?.[myTeam]?.[attackType] || 0;

              if (currentAttackCount > 0) {
                updates.pendingAttack = {
                  team: myTeam,
                  type: attackType,
                };
                updates[`attacks.${myTeam}.${attackType}`] =
                  currentAttackCount - 1;
              }
            }

            // [ФАЗА 3: ПЕРЕДАЧА ХОДА И НАЗНАЧЕНИЕ "ПЕРЕХВАТЧИКА"]
            updates.turn = opponentTeam;
            updates.turnCount = (gameData.turnCount || 0) + 1;

            const nextTurnNumber = updates.turnCount;
            const opponentSpeaker = gameData.speakers?.[opponentTeam];
            const opponentPlayers = gameData.players?.[opponentTeam] || [];
            const opponentScout = gameData.scouts?.[opponentTeam];

            if (nextTurnNumber === 1 || nextTurnNumber % 2 === 0) {
              const observers = opponentPlayers.filter(
                (p) => p !== opponentSpeaker
              );
              if (observers.length > 0) {
                let potentialScouts = observers;
                if (observers.length > 1 && opponentScout) {
                  potentialScouts = observers.filter(
                    (p) => p !== opponentScout
                  );
                }
                const newScout =
                  potentialScouts[
                    Math.floor(Math.random() * potentialScouts.length)
                  ];
                if (newScout) {
                  updates[`scouts.${opponentTeam}`] = newScout;
                }
              }
            }

            await updateDoc(doc(window.db, "games", gameId), updates);
          } catch (err) {
            console.error("End turn failed:", err);
          } finally {
            setIsSending(false);
          }
        };

        const myStatus = isMyTurn
          ? isMySpeaker
            ? "ACTIVE_SPEAKER"
            : userId === myScoutId
            ? "ACTIVE_SCOUT"
            : "OBSERVER"
          : "STANDBY";

        return (
          <div className="flex flex-col h-full bg-slate-900 w-full reveal-animation">
            <div className="p-4 bg-slate-800 text-slate-300 flex justify-between items-center text-xs font-mono border-b border-slate-700 flex-shrink-0">
              <div className="flex flex-col">
                <div className="text-white font-bold tracking-widest text-sm">
                  {gameId}
                </div>
                <div className="text-xs text-slate-400">{myStatus}</div>
              </div>
              <div
                className={`w-3 h-3 rounded-full ${
                  isMyTurn ? "bg-green-500 animate-pulse" : "bg-red-500"
                }`}
              ></div>
            </div>

            <div
              className="flex-1 overflow-y-auto p-4 space-y-6 bg-slate-900"
              ref={chatRef}
            >
              {gameData.messages.map((msg, i) => {
                const isMe = msg.team === myTeam;
                return (
                  <ChatMessage
                    key={msg.timestamp || i}
                    text={msg.text}
                    team={msg.team}
                    isMe={isMe}
                    isOpponent={!isMe}
                    themeColors={themeColors}
                  />
                );
              })}
            </div>

            <div className="bg-slate-800 border-t border-slate-700 p-2 pb-safe">
              {!isMyTurn ? (
                <div className="text-center text-slate-500 py-4 font-mono text-xs tracking-widest border-2 border-dashed border-slate-700 rounded-lg m-2">
                  <div className="flex items-center justify-center gap-3 mb-2">
                    <div className="w-2 h-2 bg-red-500 animate-pulse"></div>
                    <span className="text-red-500">[X] КАНАЛ ЗАКРЫТ</span>
                  </div>
                  <div className="text-sm text-slate-400">
                    ОЖИДАНИЕ ОППОНЕНТА...
                  </div>
                </div>
              ) : !isMySpeaker ? (
                <div className="text-center text-slate-500 py-4 font-mono text-xs tracking-widest border-2 border-dashed border-slate-700 rounded-lg m-2">
                  <div className="flex items-center justify-center gap-3 mb-2">
                    <div className="w-2 h-2 bg-yellow-500 animate-pulse"></div>
                    <span className="text-yellow-500">[!] СПИКЕР НА ЛИНИИ</span>
                  </div>
                  <div className="text-sm text-slate-400">
                    {userId === myScoutId && !isMyScoutTurn
                      ? "ОЖИДАНИЕ ДАННЫХ..."
                      : "ОЖИДАНИЕ ДЕЙСТВИЙ..."}
                  </div>
                </div>
              ) : (
                <>
                  <div className="grid grid-cols-2 gap-2 p-2">
                    {Object.entries(MANIPULATION_TYPES).map(([key, data]) => {
                      const count = myAttackCounts ? myAttackCounts[key] : 0;

                      return (
                        <button
                          key={key}
                          onClick={() =>
                            setSelectedManipulation(
                              selectedManipulation === key ? null : key
                            )
                          }
                          disabled={
                            hasAttackedThisTurn || isSending || count <= 0
                          }
                          className={`py-3 px-2 text-xs font-bold font-mono tracking-widest transition-all border-2 rounded-lg text-center ${
                            selectedManipulation === key
                              ? `${themeColors.buttonBg} ${themeColors.buttonText} ${themeColors.buttonBorder}`
                              : "bg-slate-700 text-slate-300 border-slate-700"
                          } ${
                            hasAttackedThisTurn || isSending || count <= 0
                              ? "opacity-30 cursor-not-allowed"
                              : "hover:border-slate-500"
                          }`}
                        >
                          {data.label} ({count})
                        </button>
                      );
                    })}
                  </div>
                  <form
                    onSubmit={handleSend}
                    className="flex flex-row gap-2 mb-2 items-center p-2"
                  >
                    <input
                      type="text"
                      value={message}
                      onChange={(e) => setMessage(e.target.value)}
                      placeholder={
                        isSending ? "ОТПРАВКА..." : "> Введите сообщение..."
                      }
                      disabled={isSending}
                      className={`flex-1 bg-slate-700 border-none p-3 font-mono text-sm text-white rounded-full outline-none transition placeholder:text-slate-500 ${
                        themeColors.focusBorder
                      } ${isSending ? "opacity-50" : ""}`}
                    />
                    <button
                      type="submit"
                      disabled={!message.trim() || isSending}
                      className={`${themeColors.buttonBg} text-white w-12 h-12 rounded-full flex-shrink-0 flex items-center justify-center font-bold disabled:opacity-50 ${themeColors.buttonHoverBg} transition`}
                    >
                      {isSending ? "..." : "→"}
                    </button>
                  </form>
                  <button
                    onClick={handleEndTurn}
                    disabled={isSending}
                    className="w-full py-3 bg-slate-700 text-slate-300 font-bold font-mono text-xs tracking-widest hover:bg-slate-600 transition disabled:opacity-50 rounded-lg"
                  >
                    {isSending
                      ? "ПОДОЖДИТЕ..."
                      : "ПЕРЕДАТЬ КАНАЛ [ КОНЕЦ СВЯЗИ ]"}
                  </button>
                </>
              )}
            </div>

            {isMyScoutTurn && (
              <InterceptorScreen
                onClose={() => setIsMyScoutTurn(false)}
                opponentAttacks={
                  gameData.attacks?.[myTeam === "alpha" ? "beta" : "alpha"]
                }
              />
            )}
          </div>
        );
      }

      function AdminPanel({ onExit }) {
        const [games, setGames] = useState([]);
        const [selectedGameId, setSelectedGameId] = useState(null);
        const [selectedGameData, setSelectedGameData] = useState(null);
        const [showRules, setShowRules] = useState(false);

        useEffect(
          () =>
            onSnapshot(
              query(
                collection(window.db, "games"),
                orderBy("createdAt", "desc")
              ),
              (sn) => setGames(sn.docs.map((d) => ({ id: d.id, ...d.data() })))
            ),
          []
        );

        useEffect(() => {
          if (!selectedGameId) {
            setSelectedGameData(null);
            return;
          }
          return onSnapshot(
            doc(window.db, "games", selectedGameId),
            (docSnap) => {
              if (docSnap.exists())
                setSelectedGameData({ id: docSnap.id, ...docSnap.data() });
            }
          );
        }, [selectedGameId]);

        const deleteGame = async (id) => {
          if (
            window.confirm(
              `Вы уверены, что хотите удалить сессию ${id}? Это действие необратимо.`
            )
          ) {
            if (selectedGameId === id) {
              setSelectedGameId(null);
            }
            await deleteDoc(doc(window.db, "games", id));
          }
        };

        const createGame = async () => {
          const id = Math.random().toString(36).substring(2, 7).toUpperCase();
          await setDoc(doc(window.db, "games", id), {
            createdAt: Date.now(),
            status: "active",
            turn: "alpha",
            turnCount: 0,
            messages: [],
            scores: { alpha: 0, beta: 0 },
            // [!!!] ИЗМЕНЕНИЕ: 'shields' и 'currentTurnUsedDefense' удалены
            manipulationLog: [],
            players: { alpha: [], beta: [] },
            speakers: { alpha: null, beta: null },
            scouts: { alpha: null, beta: null },
            pendingAttack: null,
            attacks: {
              alpha: { GUILT: 4, FEAR: 4, AUTHORITY: 4, FLATTERY: 4 },
              beta: { GUILT: 4, FEAR: 4, AUTHORITY: 4, FLATTERY: 4 },
            },
          });
        };

        const rerollSpeaker = async (team) => {
          const playersList = selectedGameData?.players?.[team] || [];
          if (playersList.length === 0)
            return alert("NO PLAYERS IN TEAM " + team.toUpperCase());

          const currentSpeaker = selectedGameData.speakers?.[team];
          const currentScout = selectedGameData.scouts?.[team];

          let availableCandidates = playersList;

          if (playersList.length > 1 && currentSpeaker) {
            availableCandidates = playersList.filter(
              (p) => p !== currentSpeaker
            );
          }

          if (availableCandidates.length > 1 && currentScout) {
            availableCandidates = availableCandidates.filter(
              (p) => p !== currentScout
            );
          }

          if (availableCandidates.length === 0 && playersList.length > 1) {
            availableCandidates = playersList.filter(
              (p) => p !== currentSpeaker
            );
          }

          if (availableCandidates.length === 0) {
            availableCandidates = playersList;
          }

          const nextSpeaker =
            availableCandidates[
              Math.floor(Math.random() * availableCandidates.length)
            ];

          if (nextSpeaker) {
            await updateDoc(doc(window.db, "games", selectedGameId), {
              [`speakers.${team}`]: nextSpeaker,
            });
          }
        };

        const rerollScout = async (team) => {
          const playersList = selectedGameData?.players?.[team] || [];
          if (playersList.length === 0)
            return alert("NO PLAYERS IN TEAM " + team.toUpperCase());

          const currentSpeaker = selectedGameData.speakers?.[team];
          const currentScout = selectedGameData.scouts?.[team];

          let availableCandidates = playersList.filter(
            (p) => p !== currentSpeaker
          );

          if (availableCandidates.length > 1 && currentScout) {
            availableCandidates = availableCandidates.filter(
              (p) => p !== currentScout
            );
          }

          if (availableCandidates.length === 0) {
            return alert("NOT ENOUGH OBSERVERS TO REROLL SCOUT");
          }

          const nextScout =
            availableCandidates[
              Math.floor(Math.random() * availableCandidates.length)
            ];

          if (nextScout) {
            await updateDoc(doc(window.db, "games", selectedGameId), {
              [`scouts.${team}`]: nextScout,
            });
          }
        };

        return (
          <div className="h-full flex flex-col bg-slate-900 text-slate-200 font-mono">
            <div className="bg-slate-900 text-white p-4 flex justify-between items-center border-b border-slate-700">
              <h1 className="font-bold tracking-widest text-glow">
                ADMIN_TERMINAL
              </h1>
              <div className="flex gap-2 text-xs">
                <button
                  onClick={() => setShowRules(true)}
                  className="bg-slate-700 px-3 py-2 hover:bg-slate-600 transition rounded-lg"
                >
                  [ RULES ]
                </button>
                <button
                  onClick={createGame}
                  className="bg-blue-600 px-3 py-2 hover:bg-blue-500 transition rounded-lg"
                >
                  [ NEW SESSION ]
                </button>
                <button
                  onClick={onExit}
                  className="bg-slate-700 px-3 py-2 hover:bg-slate-600 transition rounded-lg"
                >
                  [ EXIT ]
                </button>
              </div>
            </div>
            <div className="flex-1 flex flex-col md:flex-row overflow-hidden">
              <div className="w-full md:w-64 bg-slate-800 border-b md:border-b-0 md:border-r border-slate-700 h-48 md:h-full overflow-y-auto">
                {games.map((g) => (
                  <div
                    key={g.id}
                    onClick={() => setSelectedGameId(g.id)}
                    className={`flex justify-between items-center p-4 border-b border-slate-700 cursor-pointer hover:bg-slate-700/50 transition ${
                      selectedGameId === g.id ? "bg-slate-700/50" : ""
                    }`}
                  >
                    <div>
                      <div
                        className={`text-sm ${
                          selectedGameId === g.id
                            ? "text-white font-bold"
                            : "text-slate-300"
                        }`}
                      >
                        {g.id}
                      </div>
                      <div
                        className={`text-xs ${
                          g.status === "active"
                            ? "text-green-500"
                            : "text-slate-500"
                        }`}
                      >
                        {g.status}
                      </div>
                    </div>
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        deleteGame(g.id);
                      }}
                      className="text-red-500 hover:text-red-400 text-xs font-bold"
                    >
                      [X]
                    </button>
                  </div>
                ))}
              </div>
              {selectedGameData ? (
                <div className="flex-1 p-6 overflow-y-auto bg-slate-900">
                  <div className="flex justify-between items-center mb-8">
                    <h2 className="text-2xl font-bold tracking-tight text-white">
                      {selectedGameData.id}
                    </h2>
                    {selectedGameData.status === "active" && (
                      <button
                        onClick={() =>
                          updateDoc(doc(window.db, "games", selectedGameId), {
                            status: "revealed",
                          })
                        }
                        className="bg-red-600 text-white px-4 py-2 text-xs font-bold tracking-widest hover:bg-red-700 transition rounded-lg"
                      >
                        TERMINATE SESSION
                      </button>
                    )}
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    {["alpha", "beta"].map((team) => {
                      const teamPlayers =
                        selectedGameData.players?.[team] || [];
                      const currentSpeaker = selectedGameData.speakers?.[team];
                      const currentScout = selectedGameData.scouts?.[team];
                      return (
                        <div
                          key={team}
                          className="p-6 bg-slate-800 border-2 border-slate-700 rounded-lg"
                        >
                          <h3 className="font-bold uppercase mb-4 text-sm tracking-widest text-white">
                            {team} TEAM [{teamPlayers.length}]
                          </h3>
                          <div className="text-xs mb-2 text-slate-400">
                            ACTIVE_SPEAKER:{" "}
                            <span className="font-mono bg-slate-700 px-2 py-1 text-slate-200 rounded">
                              {currentSpeaker
                                ? currentSpeaker.slice(-8)
                                : "N/A"}
                            </span>
                          </div>

                          <div className="text-xs mb-4 text-slate-400">
                            ACTIVE_SCOUT:{" "}
                            <span className="font-mono bg-slate-700 px-2 py-1 text-slate-200 rounded">
                              {currentScout ? currentScout.slice(-8) : "N/A"}
                            </span>
                          </div>

                          <div className="mb-4">
                            <div className="text-xs font-bold mb-2 text-slate-300">
                              MEMBERS:
                            </div>
                            <div className="max-h-32 overflow-y-auto border border-slate-700 p-2 bg-slate-900 text-xs rounded">
                              {teamPlayers.length > 0 ? (
                                teamPlayers.map((pid) => (
                                  <div
                                    key={pid}
                                    className={`font-mono ${
                                      pid === currentSpeaker
                                        ? "text-blue-400 font-bold"
                                        : pid === currentScout
                                        ? "text-yellow-400"
                                        : "text-slate-500"
                                    }`}
                                  >
                                    <span className="opacity-50 mr-1">></span>{" "}
                                    {pid.slice(-8)}...{" "}
                                    {pid === currentSpeaker ? "[SPEAKER]" : ""}
                                    {pid === currentScout ? "[SCOUT]" : ""}
                                  </div>
                                ))
                              ) : (
                                <div className="text-slate-500 italic">
                                  NO PLAYERS JOINED
                                </div>
                              )}
                            </div>
                          </div>

                          <div className="grid grid-cols-2 gap-2">
                            <button
                              onClick={() => rerollSpeaker(team)}
                              className="w-full py-3 bg-slate-700 text-white text-xs font-bold tracking-widest hover:bg-slate-600 transition rounded-lg"
                            >
                              REROLL SPEAKER
                            </button>
                            <button
                              onClick={() => rerollScout(team)}
                              className="w-full py-3 bg-slate-700 text-white text-xs font-bold tracking-widest hover:bg-slate-600 transition rounded-lg"
                            >
                              REROLL SCOUT
                            </button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  <h3 className="font-bold uppercase mb-4 text-sm tracking-widest text-white">
                    MANIPULATION LOG
                  </h3>
                  <div className="bg-slate-800 border-2 border-slate-700 p-4 max-h-96 overflow-y-auto text-xs font-mono rounded-lg">
                    {selectedGameData.manipulationLog?.length === 0 ? (
                      <div className="text-slate-500 text-center py-4">
                        NO DATA
                      </div>
                    ) : (
                      [...selectedGameData.manipulationLog]
                        .reverse()
                        .map((log, i) => (
                          <div
                            key={i}
                            className={`p-3 mb-2 border-l-2 ${
                              log.success
                                ? "border-green-500 bg-green-900/30"
                                : log.defenseSuccess
                                ? "border-blue-500 bg-blue-900/30"
                                : "border-red-500 bg-red-900/30"
                            } rounded-r-lg`}
                          >
                            <div className="flex justify-between mb-1 opacity-75">
                              <span>
                                {log.attacker} -> {log.victim}
                              </span>
                              <span className="font-bold text-right">
                                [
                                {MANIPULATION_TYPES[log.type]?.label ||
                                  log.type}
                                ]
                              </span>
                            </div>
                            <div className="text-slate-200 break-words">
                              "{log.response}"
                            </div>

                            {log.defenseSuccess && (
                              <div className="text-blue-400 text-xs font-bold mt-1">
                                [STRONG_DEFENSE: +1 PT]
                              </div>
                            )}
                            {log.aiResponse && (
                              <div className="text-xs font-bold mt-2 p-2 bg-slate-900 border border-slate-700 rounded text-yellow-400">
                                AI_RESPONSE: {log.aiResponse}
                              </div>
                            )}
                          </div>
                        ))
                    )}
                  </div>

                  <h3 className="font-bold uppercase mb-4 text-sm tracking-widest mt-8 text-white">
                    CHAT LOG
                  </h3>
                  <div className="bg-slate-800 border-2 border-slate-700 p-4 max-h-96 overflow-y-auto text-xs font-mono rounded-lg">
                    {selectedGameData.messages?.length === 0 ? (
                      <div className="text-slate-500 text-center py-4">
                        NO MESSAGES
                      </div>
                    ) : (
                      selectedGameData.messages?.map((msg, i) => {
                        const isAttack = msg.manipulationAttempt;
                        return (
                          <div
                            key={i}
                            className={`p-3 mb-2 border-l-2 ${
                              isAttack
                                ? "border-blue-500 bg-blue-900/30"
                                : "border-slate-700 bg-slate-900/50"
                            } rounded-r-lg`}
                          >
                            <div className="flex justify-between mb-2 opacity-75">
                              <span className="font-bold text-slate-300">
                                {msg.team.toUpperCase()}
                              </span>
                              <span className="font-mono text-slate-400">
                                {msg.senderId?.slice(-8)}
                              </span>
                            </div>
                            {isAttack && (
                              <div className="font-bold text-blue-400 text-[10px] mb-2">
                                [ATTEMPT:{" "}
                                {MANIPULATION_TYPES[isAttack]?.label ||
                                  isAttack}
                                ]
                              </div>
                            )}
                            <div className="text-slate-200 break-words">
                              {msg.text}
                            </div>
                          </div>
                        );
                      })
                    )}
                  </div>
                </div>
              ) : (
                <div className="flex-1 flex items-center justify-center text-slate-500 text-xs tracking-widest">
                  SELECT SESSION
                </div>
              )}
            </div>
            {showRules && (
              <div
                className="fixed inset-0 bg-slate-900/90 z-50 flex items-center justify-center p-6 text-slate-200"
                onClick={() => setShowRules(false)}
              >
                <div
                  className="bg-slate-800 max-w-2xl w-full p-8 border border-slate-700 max-h-[90vh] overflow-y-auto rounded-lg"
                  onClick={(e) => e.stopPropagation()}
                >
                  <h2 className="text-xl font-bold mb-6 text-white tracking-widest">
                    МЕХАНИКА ИГРЫ (ДЛЯ АДМИНА)
                  </h2>
                  <div className="space-y-6 text-sm">
                    <section>
                      <h3 className="font-bold text-blue-400 mb-2">1. ЦЕЛЬ</h3>
                      <p>Набрать очки за успешные атаки И успешные защиты.</p>
                    </section>
                    <section>
                      <h3 className="font-bold text-green-400 mb-2">
                        2. УСПЕШНАЯ АТАКА (AI: VULNERABLE)
                      </h3>
                      <p>+1 очко Атакующему. Нейросеть сочла ответ уязвимым.</p>
                    </section>
                    <section>
                      <h3 className="font-bold text-red-400 mb-2">
                        3. НЕЙТРАЛЬНЫЙ ОТВЕТ (AI: NEUTRAL)
                      </h3>
                      <p>
                        0 очков. Атака не прошла, но и защита не была
                        выдающейся.
                      </p>
                    </section>
                    <section>
                      <h3 className="font-bold text-blue-400 mb-2">
                        4. СИЛЬНАЯ ЗАЩИТА (AI: STRONG_DEFENSE)
                      </h3>
                      <p>
                        +1 очко Защитнику. Нейросеть сочла, что "Жертва" активно
                        и успешно парировала атаку.
                      </p>
                    </section>
                  </div>
                  <button
                    onClick={() => setShowRules(false)}
                    className="mt-8 w-full py-4 bg-white text-slate-900 font-bold tracking-widest hover:bg-slate-200 transition rounded-lg"
                  >
                    [ ЗАКРЫТЬ ]
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      }

      // [!!!] ИЗМЕНЕНИЕ: Компонент `DebriefCard` удален.

      // [!!!] ИЗМЕНЕНИЕ: Компонент `RevealScreen` полностью переписан
      function RevealScreen({ gameData, myTeam, onExit }) {
        const myScore = gameData.scores?.[myTeam] || 0;
        const opTeam = myTeam === "alpha" ? "beta" : "alpha";
        const opScore = gameData.scores?.[opTeam] || 0;

        const [typedTitle, isTitleDone] = useTypewriter("ПОЛНЫЙ АНАЛИЗ", 60);

        const attacksOnMe = gameData.manipulationLog.filter(
          (log) => log.victim === myTeam
        );
        const myAttacks = gameData.manipulationLog.filter(
          (log) => log.attacker === myTeam
        );

        const renderLogEntry = (log, index) => {
          let borderColor = "border-red-500"; // NEUTRAL
          let aiColor = "text-red-400";
          if (log.success) {
            // VULNERABLE
            borderColor = "border-green-500";
            aiColor = "text-green-400";
          } else if (log.defenseSuccess) {
            // STRONG_DEFENSE
            borderColor = "border-blue-500";
            aiColor = "text-blue-400";
          }

          return (
            <div
              key={index}
              className={`bg-slate-800 border border-slate-700 p-4 rounded-lg border-l-4 ${borderColor} mb-4`}
            >
              <div className="flex justify-between items-center mb-3">
                <span className="text-xs text-slate-400">ТИП АТАКИ:</span>
                <span className="px-3 py-1 bg-slate-700 text-slate-200 text-sm font-bold rounded">
                  {MANIPULATION_TYPES[log.type]?.label || log.type}
                </span>
              </div>
              <div className="mb-3">
                <span className="text-xs text-slate-400">ОТВЕТ:</span>
                <blockquote className="mt-2 p-3 bg-slate-900 border border-slate-700 text-slate-300 italic rounded-md">
                  "{log.response || "(Нет ответа)"}"
                </blockquote>
              </div>
              <div>
                <span className="text-xs text-slate-400">ВЕРДИКТ ИИ:</span>
                <div className={`text-lg font-mono font-bold mt-1 ${aiColor}`}>
                  [{log.aiResponse}]
                </div>
              </div>
            </div>
          );
        };

        return (
          <div className="fixed inset-0 bg-slate-900 text-white p-4 sm:p-8 flex flex-col items-center justify-center text-center reveal-animation overflow-y-auto scrollbar-hide">
            {/* Обертка для прокрутки контента */}
            <div className="w-full h-full overflow-y-auto scrollbar-hide">
              <h1 className="text-4xl sm:text-6xl font-black my-6 tracking-tighter text-red-500 animate-pulse-slow text-glow-red">
                СИМУЛЯЦИЯ ЗАВЕРШЕНА
              </h1>
              <p className="text-lg text-slate-400 mb-12 max-w-2xl leading-relaxed mx-auto">
                Это были не переговоры. Система оценивала вашу уязвимость к{" "}
                <strong className="text-white">
                  скрытому психологическому воздействию
                </strong>{" "}
                и способность применять его.
              </p>

              <div className="flex flex-col sm:flex-row w-full max-w-md justify-between mb-12 border-t border-b border-slate-800 sm:py-8 font-mono mx-auto">
                <div className="text-center flex-1 sm:border-r border-b sm:border-b-0 border-slate-800 py-8 sm:py-0">
                  <div className="text-xs uppercase tracking-widest text-slate-500 mb-2">
                    ВАШ РЕЗУЛЬТАТ
                  </div>
                  <div
                    className="text-7xl font-black animate-pop-in"
                    style={{ animationDelay: "0.5s" }}
                  >
                    {myScore}
                  </div>
                </div>
                <div className="text-center flex-1 opacity-50 py-8 sm:py-0">
                  <div className="text-xs uppercase tracking-widest text-slate-500 mb-2">
                    ОППОНЕНТ
                  </div>
                  <div
                    className="text-7xl font-black animate-pop-in"
                    style={{ animationDelay: "0.7s" }}
                  >
                    {opScore}
                  </div>
                </div>
              </div>

              {/* ПОЛНЫЕ ЛОГИ */}
              <div
                className="w-full max-w-2xl mb-12 space-y-8 text-left animate-pop-in mx-auto"
                style={{ animationDelay: "0.9s" }}
              >
                <div className="text-center">
                  <h3
                    className={`text-xl font-bold text-white tracking-widest inline-block ${
                      isTitleDone ? "typing-caret-done" : "typing-caret"
                    }`}
                  >
                    {typedTitle}
                  </h3>
                </div>

                <section>
                  <h4 className="text-lg font-bold text-slate-100 mb-4 pb-2 border-b border-slate-700">
                    АНАЛИЗ ВАШЕЙ ЗАЩИТЫ
                  </h4>
                  {attacksOnMe.length === 0 ? (
                    <p className="text-slate-400 italic">
                      Против вас не было атак.
                    </p>
                  ) : (
                    attacksOnMe.map(renderLogEntry)
                  )}
                </section>

                <section>
                  <h4 className="text-lg font-bold text-slate-100 mb-4 pb-2 border-b border-slate-700">
                    АНАЛИЗ ВАШИХ АТАК
                  </h4>
                  {myAttacks.length === 0 ? (
                    <p className="text-slate-400 italic">
                      Вы не провели ни одной атаки.
                    </p>
                  ) : (
                    myAttacks.map(renderLogEntry)
                  )}
                </section>
              </div>

              <button
                onClick={onExit}
                className="py-4 px-12 bg-white text-slate-900 font-bold font-mono tracking-widest hover:bg-slate-200 transition animate-pop-in rounded-lg mb-8"
                style={{ animationDelay: "1.2s" }}
              >
                [ ⏏ ВЫХОД ]
              </button>
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
